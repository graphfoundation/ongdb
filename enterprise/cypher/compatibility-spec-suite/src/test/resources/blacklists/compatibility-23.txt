Feature "Aggregation": Scenario "`max()` over list values"
Feature "Aggregation": Scenario "`max()` over mixed numeric values"
Feature "Aggregation": Scenario "`max()` over mixed values"
Feature "Aggregation": Scenario "`max()` over strings"
Feature "Aggregation": Scenario "`min()` over list values"
Feature "Aggregation": Scenario "`min()` over mixed numeric values"
Feature "Aggregation": Scenario "`min()` over mixed values"
Feature "Aggregation": Scenario "`min()` over strings"
Feature "AggregationAcceptance": Scenario "`max()` should aggregate strings"
Feature "AggregationAcceptance": Scenario "`min()` should aggregate strings"
Feature "Comparability": Scenario "Comparing across types yields null, except numbers"
Feature "Comparability": Scenario "Comparing strings and integers using > in a OR'd predicate"
Feature "Comparability": Scenario "Comparing strings and integers using > in an AND'd predicate"
Feature "CreateAcceptance": Scenario "Combine MATCH, WITH and CREATE"
Feature "DeleteAcceptance": Scenario "Delete node from a list"
Feature "DeleteAcceptance": Scenario "Delete relationship from a list"
Feature "DurationBetweenAcceptance": Scenario "Should compute duration between if they differ only by a fraction of a second and the first comes after the second."
Feature "DurationBetweenAcceptance": Scenario "Should compute duration between two temporals in days"
Feature "DurationBetweenAcceptance": Scenario "Should compute duration between two temporals in months"
Feature "DurationBetweenAcceptance": Scenario "Should compute duration between two temporals in seconds"
Feature "DurationBetweenAcceptance": Scenario "Should compute duration between two temporals"
Feature "DurationBetweenAcceptance": Scenario "Should compute durations with no difference"
Feature "DurationBetweenAcceptance": Scenario "Should compute negative duration between in big units"
Feature "DurationBetweenAcceptance": Scenario "Should handle durations at daylight saving time day"
Feature "DurationBetweenAcceptance": Scenario "Should handle large durations in seconds"
Feature "DurationBetweenAcceptance": Scenario "Should handle large durations"
Feature "DurationBetweenAcceptance": Scenario "Should handle when seconds and subseconds have different signs"
Feature "DurationBetweenAcceptance": Scenario "Should propagate null"
Feature "DurationBetweenAcceptance": Scenario "Should split between boundaries correctly"
Feature "EqualsAcceptance": Scenario "Any-typed string comparison"
Feature "EqualsAcceptance": Scenario "Number-typed float comparison"
Feature "EqualsAcceptance": Scenario "Number-typed integer comparison"
Feature "ExpressionAcceptance": Scenario "Fail at runtime when attempting to index with a String into a Collection"
Feature "ExpressionAcceptance": Scenario "Fail at runtime when attempting to index with an Int into a Map"
Feature "ExpressionAcceptance": Scenario "Fail at runtime when trying to index into a list with a list"
Feature "ExpressionAcceptance": Scenario "Fail at runtime when trying to index into a map with a non-string"
Feature "ExpressionAcceptance": Scenario "Fail at runtime when trying to index something which is not a map or collection"
Feature "ExpressionAcceptance": Scenario "Fail at runtime when trying to index something which is not a map or list"
Feature "ExpressionAcceptance": Scenario "IN should work with list slices"
Feature "ExpressionAcceptance": Scenario "IN should work with literal list slices"
Feature "ExpressionAcceptance": Scenario "IN should work with nested list subscripting"
Feature "ExpressionAcceptance": Scenario "IN should work with nested literal list subscripting"
Feature "ExpressionAcceptance": Scenario "Use collection lookup based on parameters when there is lhs type information"
Feature "ExpressionAcceptance": Scenario "Use collection lookup based on parameters when there is no type information"
Feature "ExpressionAcceptance": Scenario "Use collection lookup based on parameters when there is rhs type information"
Feature "ExpressionAcceptance": Scenario "Use dynamic property lookup based on parameters when there is lhs type information"
Feature "ExpressionAcceptance": Scenario "Use dynamic property lookup based on parameters when there is no type information"
Feature "ExpressionAcceptance": Scenario "Use dynamic property lookup based on parameters when there is rhs type information"
Feature "FunctionsAcceptance": Scenario "`labels()` failing on invalid arguments"
Feature "FunctionsAcceptance": Scenario "`labels()` should accept type Any"
Feature "FunctionsAcceptance": Scenario "`percentileCont()` failing on bad arguments"
Feature "FunctionsAcceptance": Scenario "`percentileCont()`"
Feature "FunctionsAcceptance": Scenario "`percentileDisc()` failing in more involved query"
Feature "FunctionsAcceptance": Scenario "`percentileDisc()` failing on bad arguments"
Feature "FunctionsAcceptance": Scenario "`percentileDisc()`"
Feature "FunctionsAcceptance": Scenario "`properties()` failing on a list of booleans"
Feature "FunctionsAcceptance": Scenario "`properties()` failing on a string literal"
Feature "FunctionsAcceptance": Scenario "`properties()` failing on an integer literal"
Feature "FunctionsAcceptance": Scenario "`properties()` on a map"
Feature "FunctionsAcceptance": Scenario "`properties()` on a node"
Feature "FunctionsAcceptance": Scenario "`properties()` on a relationship"
Feature "FunctionsAcceptance": Scenario "`properties()` on null"
Feature "FunctionsAcceptance": Scenario "`type()` failing on invalid arguments"
Feature "FunctionsAcceptance": Scenario "`type()` handling Any type"
Feature "KeysAcceptance": Scenario "Using `keys()` on a parameter map"
Feature "LabelsAcceptance": Scenario "Fail when adding new label predicate on a node that is already bound 5"
Feature "ListOperations": Scenario "Equality between almost equal lists with null should return null"
Feature "ListOperations": Scenario "Equality between almost equal nested lists with null should return null"
Feature "ListOperations": Scenario "Fail at runtime when attempting to index with a String into a List"
Feature "ListOperations": Scenario "Fail at runtime when trying to index into a list with a list"
Feature "ListOperations": Scenario "IN should return null if comparison with null is required, list version 2"
Feature "ListOperations": Scenario "IN should return null if comparison with null is required, list version"
Feature "ListOperations": Scenario "IN should return null if LHS and RHS are null - list version"
Feature "ListOperations": Scenario "IN should return null when comparing two so-called identical lists where one element is null"
Feature "ListOperations": Scenario "IN should work with list slices"
Feature "ListOperations": Scenario "IN should work with literal list slices"
Feature "ListOperations": Scenario "IN should work with nested list subscripting"
Feature "ListOperations": Scenario "IN should work with nested literal list subscripting"
Feature "ListOperations": Scenario "List slice with parameterised invalid range"
Feature "ListOperations": Scenario "List slice with parameterised range"
Feature "ListOperations": Scenario "Use list lookup based on parameters when there is lhs type information"
Feature "ListOperations": Scenario "Use list lookup based on parameters when there is no type information"
Feature "ListOperations": Scenario "Use list lookup based on parameters when there is rhs type information"
Feature "MatchAcceptance": Scenario "Use params in pattern matching predicates"
Feature "MatchAcceptance2": Scenario "Matching with many predicates and larger pattern"
Feature "MergeRelationshipAcceptance": Scenario "Fail when imposing new predicates on a variable that is already bound"
Feature "MiscellaneousErrorAcceptance": Scenario "Failing on merging node with null property"
Feature "MiscellaneousErrorAcceptance": Scenario "Failing on merging relationship with null property"
Feature "MiscellaneousErrorAcceptance": Scenario "Failing when setting a list of maps as a property"
Feature "NullAcceptance": Scenario "Ignore null when removing label"
Feature "NullAcceptance": Scenario "Ignore null when setting label"
Feature "NullAcceptance": Scenario "Ignore null when setting properties using an appending map"
Feature "NullAcceptance": Scenario "Ignore null when setting properties using an overriding map"
Feature "NullOperator": Scenario "Property not null check on null node"
Feature "OrderByAcceptance": Scenario "ORDER BY with negative parameter for LIMIT should not generate errors"
Feature "PatternComprehension": Scenario "Aggregating on pattern comprehension"
Feature "PatternComprehension": Scenario "Get node degree via size of pattern comprehension that specifies a relationship type"
Feature "PatternComprehension": Scenario "Get node degree via size of pattern comprehension that specifies multiple relationship types"
Feature "PatternComprehension": Scenario "Get node degree via size of pattern comprehension"
Feature "PatternComprehension": Scenario "Introducing new node variable in pattern comprehension"
Feature "PatternComprehension": Scenario "Introducing new relationship variable in pattern comprehension"
Feature "PatternComprehension": Scenario "Pattern comprehension and ORDER BY"
Feature "PatternComprehension": Scenario "Pattern comprehension inside list comprehension"
Feature "PatternComprehension": Scenario "Returning a pattern comprehension with bound nodes"
Feature "PatternComprehension": Scenario "Returning a pattern comprehension with label predicate"
Feature "PatternComprehension": Scenario "Returning a pattern comprehension"
Feature "PatternComprehension": Scenario "Using a pattern comprehension in a WITH"
Feature "PatternComprehension": Scenario "Using a variable-length pattern comprehension in a WITH"
Feature "PatternComprehension": Scenario "Using pattern comprehension in RETURN"
Feature "PatternComprehension": Scenario "Using pattern comprehension to test existence"
Feature "ProcedureCallAcceptance": Scenario "Calling the same procedure twice using the same outputs in each call"
Feature "ProcedureCallAcceptance": Scenario "In-query call to procedure should fail if explicit argument is missing"
Feature "ProcedureCallAcceptance": Scenario "In-query call to procedure should fail if input type is wrong"
Feature "ProcedureCallAcceptance": Scenario "In-query call to procedure should fail if too many explicit argument are given"
Feature "ProcedureCallAcceptance": Scenario "In-query call to procedure that both takes arguments and has outputs fails if the arguments are passed implicitly and no outputs are yielded"
Feature "ProcedureCallAcceptance": Scenario "In-query call to procedure that has outputs fails if no outputs are yielded"
Feature "ProcedureCallAcceptance": Scenario "In-query call to procedure that takes arguments fails when trying to pass them implicitly"
Feature "ProcedureCallAcceptance": Scenario "In-query call to procedure that takes no arguments and yields no results"
Feature "ProcedureCallAcceptance": Scenario "In-query call to procedure that takes no arguments"
Feature "ProcedureCallAcceptance": Scenario "In-query call to procedure with argument of type FLOAT accepts value of type INTEGER"
Feature "ProcedureCallAcceptance": Scenario "In-query call to procedure with argument of type INTEGER accepts value of type FLOAT"
Feature "ProcedureCallAcceptance": Scenario "In-query call to procedure with argument of type NUMBER accepts value of type FLOAT"
Feature "ProcedureCallAcceptance": Scenario "In-query call to procedure with argument of type NUMBER accepts value of type INTEGER"
Feature "ProcedureCallAcceptance": Scenario "In-query call to procedure with explicit arguments that drops all result fields"
Feature "ProcedureCallAcceptance": Scenario "In-query call to procedure with explicit arguments"
Feature "ProcedureCallAcceptance": Scenario "In-query call to procedure with null argument"
Feature "ProcedureCallAcceptance": Scenario "In-query call to unknown procedure should fail"
Feature "ProcedureCallAcceptance": Scenario "In-query call to VOID procedure does not consume rows"
Feature "ProcedureCallAcceptance": Scenario "In-query call to VOID procedure that takes no arguments"
Feature "ProcedureCallAcceptance": Scenario "In-query procedure call should fail if one of the argument expressions uses an aggregation function"
Feature "ProcedureCallAcceptance": Scenario "In-query procedure call should fail if shadowing an already bound variable"
Feature "ProcedureCallAcceptance": Scenario "Standalone call to procedure should fail if explicit argument is missing"
Feature "ProcedureCallAcceptance": Scenario "Standalone call to procedure should fail if implicit argument is missing"
Feature "ProcedureCallAcceptance": Scenario "Standalone call to procedure should fail if input type is wrong"
Feature "ProcedureCallAcceptance": Scenario "Standalone call to procedure should fail if too many explicit argument are given"
Feature "ProcedureCallAcceptance": Scenario "Standalone call to procedure that takes no arguments and yields no results, called with implicit arguments"
Feature "ProcedureCallAcceptance": Scenario "Standalone call to procedure that takes no arguments and yields no results"
Feature "ProcedureCallAcceptance": Scenario "Standalone call to procedure that takes no arguments"
Feature "ProcedureCallAcceptance": Scenario "Standalone call to procedure with argument of type FLOAT accepts value of type INTEGER"
Feature "ProcedureCallAcceptance": Scenario "Standalone call to procedure with argument of type INTEGER accepts value of type FLOAT"
Feature "ProcedureCallAcceptance": Scenario "Standalone call to procedure with argument of type NUMBER accepts value of type FLOAT"
Feature "ProcedureCallAcceptance": Scenario "Standalone call to procedure with argument of type NUMBER accepts value of type INTEGER"
Feature "ProcedureCallAcceptance": Scenario "Standalone call to procedure with explicit arguments"
Feature "ProcedureCallAcceptance": Scenario "Standalone call to procedure with implicit arguments"
Feature "ProcedureCallAcceptance": Scenario "Standalone call to procedure with null argument"
Feature "ProcedureCallAcceptance": Scenario "Standalone call to unknown procedure should fail"
Feature "ProcedureCallAcceptance": Scenario "Standalone call to VOID procedure that takes no arguments, called with implicit arguments"
Feature "ProcedureCallAcceptance": Scenario "Standalone call to VOID procedure that takes no arguments"
Feature "ReturnAcceptance2": Scenario "Arithmetic expressions inside aggregation"
Feature "ReturnAcceptanceTest": Scenario "Absolute function"
Feature "ReturnAcceptanceTest": Scenario "Get rows in the middle by param"
Feature "ReturnAcceptanceTest": Scenario "Start the result from the second row by param"
Feature "SemanticErrorAcceptance": Scenario "Failing when performing property access on a non-map 1"
Feature "SemanticErrorAcceptance": Scenario "Failing when using parameter as node predicate in MATCH"
Feature "SemanticErrorAcceptance": Scenario "Failing when using parameter as node predicate in MERGE"
Feature "SemanticErrorAcceptance": Scenario "Failing when using parameter as relationship predicate in MATCH"
Feature "SemanticErrorAcceptance": Scenario "Failing when using parameter as relationship predicate in MERGE"
Feature "SemanticErrorAcceptance": Scenario "Handling property access on the Any type"
Feature "SkipLimitAcceptanceTest": Scenario "LIMIT with an expression that does not depend on variables"
Feature "SkipLimitAcceptanceTest": Scenario "SKIP with an expression that does not depend on variables"
Feature "StartsWithAcceptance": Scenario "Handling non-string operands for CONTAINS"
Feature "StartsWithAcceptance": Scenario "Handling non-string operands for ENDS WITH"
Feature "StartsWithAcceptance": Scenario "Handling non-string operands for STARTS WITH"
Feature "TemporalAccessorAcceptance": Scenario "Should provide accessors for date in last weekYear"
Feature "TemporalAccessorAcceptance": Scenario "Should provide accessors for date time"
Feature "TemporalAccessorAcceptance": Scenario "Should provide accessors for date"
Feature "TemporalAccessorAcceptance": Scenario "Should provide accessors for duration"
Feature "TemporalAccessorAcceptance": Scenario "Should provide accessors for local date time"
Feature "TemporalAccessorAcceptance": Scenario "Should provide accessors for local time"
Feature "TemporalAccessorAcceptance": Scenario "Should provide accessors for time"
Feature "TemporalArithmeticAcceptance": Scenario "Should add or subtract duration to or from date time"
Feature "TemporalArithmeticAcceptance": Scenario "Should add or subtract duration to or from date"
Feature "TemporalArithmeticAcceptance": Scenario "Should add or subtract duration to or from local date time"
Feature "TemporalArithmeticAcceptance": Scenario "Should add or subtract duration to or from local time"
Feature "TemporalArithmeticAcceptance": Scenario "Should add or subtract duration to or from time"
Feature "TemporalArithmeticAcceptance": Scenario "Should add or subtract durations"
Feature "TemporalArithmeticAcceptance": Scenario "Should multiply or divide durations by numbers"
Feature "TemporalComparisonAcceptance": Scenario "Should compare date times"
Feature "TemporalComparisonAcceptance": Scenario "Should compare dates"
Feature "TemporalComparisonAcceptance": Scenario "Should compare durations for equality"
Feature "TemporalComparisonAcceptance": Scenario "Should compare local date times"
Feature "TemporalComparisonAcceptance": Scenario "Should compare local times"
Feature "TemporalComparisonAcceptance": Scenario "Should compare times"
Feature "TemporalCreateAcceptance": Scenario "Should construct date time from epoch"
Feature "TemporalCreateAcceptance": Scenario "Should construct date time with default time zone"
Feature "TemporalCreateAcceptance": Scenario "Should construct date time with named time zone"
Feature "TemporalCreateAcceptance": Scenario "Should construct date time with offset time zone"
Feature "TemporalCreateAcceptance": Scenario "Should construct date"
Feature "TemporalCreateAcceptance": Scenario "Should construct duration"
Feature "TemporalCreateAcceptance": Scenario "Should construct local date time"
Feature "TemporalCreateAcceptance": Scenario "Should construct local time"
Feature "TemporalCreateAcceptance": Scenario "Should construct temporal with time offset with second precision"
Feature "TemporalCreateAcceptance": Scenario "Should construct time"
Feature "TemporalCreateAcceptance": Scenario "Should construct week date"
Feature "TemporalCreateAcceptance": Scenario "Should construct week datetime"
Feature "TemporalCreateAcceptance": Scenario "Should construct week localdatetime"
Feature "TemporalCreateAcceptance": Scenario "Should propagate null"
Feature "TemporalCreateAcceptance": Scenario "Should store date time"
Feature "TemporalCreateAcceptance": Scenario "Should store date"
Feature "TemporalCreateAcceptance": Scenario "Should store duration"
Feature "TemporalCreateAcceptance": Scenario "Should store local date time"
Feature "TemporalCreateAcceptance": Scenario "Should store local time"
Feature "TemporalCreateAcceptance": Scenario "Should store time"
Feature "TemporalParseAcceptance": Scenario "Should parse date from string"
Feature "TemporalParseAcceptance": Scenario "Should parse date time from string"
Feature "TemporalParseAcceptance": Scenario "Should parse date time with named time zone from string"
Feature "TemporalParseAcceptance": Scenario "Should parse duration from string"
Feature "TemporalParseAcceptance": Scenario "Should parse local date time from string"
Feature "TemporalParseAcceptance": Scenario "Should parse local time from string"
Feature "TemporalParseAcceptance": Scenario "Should parse time from string"
Feature "TemporalSelectAcceptance": Scenario "Should datetime into date time"
Feature "TemporalSelectAcceptance": Scenario "Should select date and time into date time"
Feature "TemporalSelectAcceptance": Scenario "Should select date and time into local date time"
Feature "TemporalSelectAcceptance": Scenario "Should select date into date time"
Feature "TemporalSelectAcceptance": Scenario "Should select date into local date time"
Feature "TemporalSelectAcceptance": Scenario "Should select date"
Feature "TemporalSelectAcceptance": Scenario "Should select datetime into local date time"
Feature "TemporalSelectAcceptance": Scenario "Should select local time"
Feature "TemporalSelectAcceptance": Scenario "Should select time into date time"
Feature "TemporalSelectAcceptance": Scenario "Should select time into local date time"
Feature "TemporalSelectAcceptance": Scenario "Should select time"
Feature "TemporalToStringAcceptance": Scenario "Should serialize date time"
Feature "TemporalToStringAcceptance": Scenario "Should serialize date"
Feature "TemporalToStringAcceptance": Scenario "Should serialize duration"
Feature "TemporalToStringAcceptance": Scenario "Should serialize local date time"
Feature "TemporalToStringAcceptance": Scenario "Should serialize local time"
Feature "TemporalToStringAcceptance": Scenario "Should serialize time"
Feature "TemporalToStringAcceptance": Scenario "Should serialize timezones correctly"
Feature "TemporalTruncateAcceptance": Scenario "Should truncate date"
Feature "TemporalTruncateAcceptance": Scenario "Should truncate datetime"
Feature "TemporalTruncateAcceptance": Scenario "Should truncate localdatetime"
Feature "TemporalTruncateAcceptance": Scenario "Should truncate localtime"
Feature "TemporalTruncateAcceptance": Scenario "Should truncate time"
Feature "TernaryLogicAcceptanceTest": Scenario "Using null in AND"
Feature "TernaryLogicAcceptanceTest": Scenario "Using null in IN"
Feature "TernaryLogicAcceptanceTest": Scenario "Using null in OR"
Feature "TernaryLogicAcceptanceTest": Scenario "Using null in XOR"
Feature "TypeConversionFunctions": Scenario "`toBoolean()` on booleans"
Feature "TypeConversionFunctions": Scenario "`toBoolean()` on invalid strings"
Feature "TypeConversionFunctions": Scenario "`toBoolean()` on invalid types"
Feature "TypeConversionFunctions": Scenario "`toBoolean()` on valid literal string"
Feature "TypeConversionFunctions": Scenario "`toBoolean()` on variables with valid string values"
Feature "TypeConversionFunctions": Scenario "`toFloat()` failing on invalid arguments"
Feature "TypeConversionFunctions": Scenario "`toFloat()` handling Any type"
Feature "TypeConversionFunctions": Scenario "`toFloat()` on mixed number types"
Feature "TypeConversionFunctions": Scenario "`toInteger()` failing on invalid arguments"
Feature "TypeConversionFunctions": Scenario "`toInteger()` handling Any type"
Feature "TypeConversionFunctions": Scenario "`toInteger()` handling mixed number types"
Feature "TypeConversionFunctions": Scenario "`toInteger()` on a complex-typed expression"
Feature "TypeConversionFunctions": Scenario "`toInteger()` on a list of strings"
Feature "TypeConversionFunctions": Scenario "`toInteger()` on float"
Feature "TypeConversionFunctions": Scenario "`toInteger()` returning null on non-numerical string"
Feature "TypeConversionFunctions": Scenario "`toInteger()`"
Feature "TypeConversionFunctions": Scenario "`toString()` failing on invalid arguments"
Feature "TypeConversionFunctions": Scenario "`toString()` handling boolean literal"
Feature "TypeConversionFunctions": Scenario "`toString()` handling boolean properties"
Feature "TypeConversionFunctions": Scenario "`toString()` handling inlined boolean"
Feature "TypeConversionFunctions": Scenario "`toString()` should work on Any type"
Feature "UnwindAcceptance": Scenario "Creating nodes from an unwound parameter list"
Feature "UnwindAcceptance": Scenario "Unwind with merge"